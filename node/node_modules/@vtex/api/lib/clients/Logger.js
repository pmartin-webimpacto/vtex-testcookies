"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HttpClient_1 = require("../HttpClient");
const error_1 = require("../utils/error");
const DEFAULT_SUBJECT = '-';
const production = process.env.VTEX_PRODUCTION === 'true';
var LogLevel;
(function (LogLevel) {
    LogLevel["Debug"] = "debug";
    LogLevel["Info"] = "info";
    LogLevel["Warn"] = "warn";
    LogLevel["Error"] = "error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
const routes = {
    Log: (level) => `/logs/${level}`,
};
class Logger extends HttpClient_1.InfraClient {
    constructor(context, options) {
        super('colossus', Object.assign({}, context, { recorder: undefined }), Object.assign({}, options, { concurrency: 1 }));
        this.debug = (message, subject = DEFAULT_SUBJECT) => this.sendLog(subject, message, LogLevel.Debug);
        this.info = (message, subject = DEFAULT_SUBJECT) => this.sendLog(subject, message, LogLevel.Info);
        this.warn = (warning, subject = DEFAULT_SUBJECT) => this.sendLog(subject, error_1.cleanError(warning), LogLevel.Warn);
        this.error = (error, subject = DEFAULT_SUBJECT) => this.sendLog(subject, error_1.cleanError(error), LogLevel.Error);
        this.sendLog = (subject, message, level) => {
            if (!message) {
                message = new Error('Logger.sendLog was called with null or undefined message');
                message.code = 'ERR_NIL_ERR';
                console.error(message);
            }
            if (message && typeof message === 'object') {
                message.production = production;
            }
            return this.http.put(routes.Log(level), message, { params: { subject }, metric: 'logger-send' });
        };
    }
}
exports.Logger = Logger;
