"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
exports.hrToMillis = ([seconds, nanoseconds]) => Math.round((seconds * 1e3) + (nanoseconds / 1e6));
exports.hrToNano = ([seconds, nanoseconds]) => seconds * 1e9 + nanoseconds;
exports.formatNano = (nanoseconds) => `${(nanoseconds / 1e9).toFixed(0)}s ${((nanoseconds / 1e6) % 1e3).toFixed(0)}ms`;
exports.reduceHrToNano = ramda_1.reduce((acc, hr) => acc + exports.hrToNano(hr), 0);
function recordTimings(start, name, timings, middlewareMetrics) {
    // Capture the total amount of time spent in this middleware
    const end = process.hrtime(start);
    timings[name] = end;
    const label = `middleware-${name}`;
    metrics.batch(label, end);
    // This middleware has added it's own metrics
    // Just add them to `timings` scoped by the middleware's name and batch them
    const middlewareMetricsKeys = ramda_1.keys(middlewareMetrics);
    if (middlewareMetricsKeys.length > 0) {
        ramda_1.forEach((k) => {
            const metricEnd = middlewareMetrics[k];
            const metricName = `${label}-${k}`;
            timings[metricName] = metricEnd;
            metrics.batch(metricName, metricEnd);
        }, middlewareMetricsKeys);
    }
}
function timer(middleware) {
    return async (ctx, next) => {
        if (!ctx.timings) {
            ctx.timings = {};
        }
        if (!ctx.metrics) {
            ctx.metrics = {};
        }
        const start = process.hrtime();
        try {
            await middleware(ctx, async () => {
                recordTimings(start, middleware.name, ctx.timings, ctx.metrics);
                ctx.metrics = {};
                if (next) {
                    await next();
                }
            });
        }
        catch (e) {
            recordTimings(start, middleware.name, ctx.timings, ctx.metrics);
            throw e;
        }
    };
}
exports.timer = timer;
